
----------------------------------------------------------------------------------------------

01.模板的声明和实现都是在头文件内进行

虽然模板中的函数也可以有自己的声明和实现，但编译器不会在读到模板实现时立刻生成实际代码，
因为具体的模板参数类型还未知，无法进行编译。对于编译器来说，模板实现也是一-种声明，声明
如何自动生成代码。所以模板的实现也应该放在头文件内，这样，在其他代码文件中可以直接将模板
的实现也包含进来，当需要生成模板实例时，编译器可根据已知模板实现当场生成，而无需依赖在别
的目标文件中生成的模板实例。但这样会带来另一个问题， 即重复模板实例。

----------------------------------------------------------------------------------------------

02.C++模板显式实例化，隐式实例化，特化(具体化,偏特化)辨析
C++只有模板显式实例化(explicit instantiation),隐式实例化(implicit instantiation),特化(specialization,也译作具体化，偏特化)。
c++标准规定显式特化必须在类所在的命名空间。

----------------------------------------------------------------------------------------------

03.C++11模版元编程

模版元程序由元数据和元函数组成，元数据就是元编程可以操作的数据，即C++编译器在编译期可以操作的数据。
元数据不是运行期变量，只能是编译期常量，不能修改，常见的元数据有enum枚举常量、静态常量、基本类型和自定义类型等。
元函数是模板元编程中用于操作处理元数据的“构件”，可以在编译期被“调用”，因为它的功能和形式和运行时的函数类似，而被称为元函数，
它是元编程中最重要的构件。元函数实际上表现为C++的一个类、模板类或模板函数，
它的通常形式如下：
template<int N, int M>
struct meta_func
{
    static const int value = N+M;
}

----------------------------------------------------------------------------------------------

04.SFINAE匹配失败不是错误

在C++模板中，SFINAE规则是指”Substitution failure is not an error“(匹配失败不是错误)。
具体来说，就是当重载的模板参数展开时，如果展开导致一些类型不匹配，编译器并不报错。
可以使用这个规则来判断类是否存在某个成员函数.






