

1
pipe:
函数原型 int pipe(int fd[2]) 
函数传入值 fd[2]:管道的两个文件描述符，之后就是可以直接操作者两个文件描述符 
返回值 成功 0 失败 -1

管道简介
管道是Linux 支持的最初Unix IPC形式之一，具有以下特点： 
管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道； 只能用于父子
进程或者兄弟进程之间（具有亲缘关系的进程）； 单独构成一种独立的文件系统：管道对于管道两端
的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成
一种文件系 统，并且只存在与内存中。 数据的读出和写入：一个进程向管道中写的内容被管道另一端
的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

创建int pipe(int fd[2])
该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义，因此，一个进程在由 pipe()
创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个
进程中存在亲缘关系，这里的亲缘关系指 的是具有共同的祖先，都可以采用管道方式来进行通信）。

管道读写
管道两端可 分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端
只能用于读，由描述字fd[0]表示，称其为管道读端；另 一端则只能用于写，由描述字fd[1]来表示，称
其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。一般文件的
I/O 函数都可以用于管道，如close、read、write等等。

规则1：写端对读端存在的依赖性
向管道中写入数据:
向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写
进程就会试 图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。 
注：只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到 内核
传来的SIFPIPE信号，应用程序可以处理该信号，也可以忽略（默认动作则是应用程序终止）。











//type __sync_fetch_and_add(type *ptr, type value, ...)
//// 将value加到*ptr上，结果更新到*ptr，并返回操作之前*ptr的值
//type __sync_fetch_and_sub(type *ptr, type value, ...)
//// 从*ptr减去value，结果更新到*ptr，并返回操作之前*ptr的值
//type __sync_fetch_and_or(type *ptr, type value, ...)
//// 将*ptr与value相或，结果更新到*ptr， 并返回操作之前*ptr的值
//type __sync_fetch_and_and(type *ptr, type value, ...)
//// 将*ptr与value相与，结果更新到*ptr，并返回操作之前*ptr的值
//type __sync_fetch_and_xor(type *ptr, type value, ...)
//// 将*ptr与value异或，结果更新到*ptr，并返回操作之前*ptr的值
//type __sync_fetch_and_nand(type *ptr, type value, ...)
//// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之前*ptr的值
//type __sync_add_and_fetch(type *ptr, type value, ...)
//// 将value加到*ptr上，结果更新到*ptr，并返回操作之后新*ptr的值
//type __sync_sub_and_fetch(type *ptr, type value, ...)
//// 从*ptr减去value，结果更新到*ptr，并返回操作之后新*ptr的值
//type __sync_or_and_fetch(type *ptr, type value, ...)
//// 将*ptr与value相或， 结果更新到*ptr，并返回操作之后新*ptr的值
//type __sync_and_and_fetch(type *ptr, type value, ...)
//// 将*ptr与value相与，结果更新到*ptr，并返回操作之后新*ptr的值
//type __sync_xor_and_fetch(type *ptr, type value, ...)
//// 将*ptr与value异或，结果更新到*ptr，并返回操作之后新*ptr的值
//type __sync_nand_and_fetch(type *ptr, type value, ...)
//// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之后新*ptr的值
//bool __sync_bool_compare_and_swap(type *ptr, type oldval type newval, ...)
//// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true
//type __sync_val_compare_and_swap(type *ptr, type oldval type newval, ...)
//// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回操作之前*ptr的值
//__sync_synchronize(...)
//// 发出完整内存栅栏
//type __sync_lock_test_and_set(type *ptr, type value, ...)
//// 将value写入*ptr，对*ptr加锁，并返回操作之前*ptr的值。即，try spinlock语义
//void __sync_lock_release(type *ptr, ...)
//// 将0写入到*ptr，并对*ptr解锁。即，unlock spinlock语义
