
/*
https://blog.codingnow.com/2013/08/full_userdata_gc.html
https://blog.codingnow.com/2012/02/ring_buffer.html

需求是这样的：skynet 提供了一个用 C 编写的异步 socket 库，所有 socket 请求都是通过一个消息队列分发
回来的。我希望封装成 Lua 版的 api 时可以去掉这些。我需要给每个 socket 对象绑定一个数据队列，一旦有
socket 数据发进来就串在队列上，然后再逐个解析。

在 https://github.com/cloudwu/skynet/blob/master/lualib-src/lua-socket.c 里我定义了这样的数据结构：

struct buffer_node {
char * msg;
int sz;
struct buffer_node *next;
};

struct socket_buffer {
int size;
int offset; //  offset 域, 记录未处理的数据块头部偏移。
struct buffer_node *head;
struct buffer_node *tail;
};

需要封装的是 struct socket_buffer 结构，它里面引用了一个链表 struct buffer_node 。每组 socket 数据会
以 struct buffer_node 的形式从底层产生，被挂接到 struct socket_buffer 的链表中。在运行过程中，随着程
序运行，处理过的 socket 数据又会被释放。

我干脆一次申请了大块内存保存多个 struct buffer_node ，暂时用不到的内存，把它们串成一个 freelist 放在
lua 的一张表中，不到 lua vm 关闭前不释放。而所有需要传入 struct socket_buffer 的地方，都再传一个存放
有 freelist 的 lua table 负责管理新创建以及需要销毁的 struct buffer_node 。

如此，封装 struct buffer_node 和 struct socket_buffer 成为 lua 的 userdata 就都不需要 gc 元方法了。

当然，这个方法仅仅只是保证最终没有内存泄露，socket_buffer 依旧需要一个显式的关闭操作。这个道理跟 socket fd
需要显式关闭而不能等 GC 再关闭一样。

这个技巧还可以用于树结构的管理。就不具体展开了。

总结：把碎片结构放到一个 userdata 构成的 freelist 池中，然后从 userdata 里引用池内的结构。这样就可以
避免给每个 userdata 指定 GC 方法来释放其中的链表或树节点。

把所有内存都交给 lua 去管理（这里提到的内存分配都是利用的 lua_newuserdata ，它是被 lua 管理起来的）对
GC 也更加友好。Lua 可以更清楚的了解你的程序用掉了多少内存以合理调配 GC 的进度。

*/


#define LUA_LIB

#include "skynet_malloc.h"

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <assert.h>

#include <lua.h>
#include <lauxlib.h>

#include <sys/socket.h>
#include <arpa/inet.h>

#include "skynet_socket.h"

#define BACKLOG 32
// 2 ** 12 == 4096
#define LARGE_PAGE_NODE 12
#define BUFFER_LIMIT (256 * 1024)

struct buffer_node {
	char * msg;
	int sz;
	struct buffer_node *next;
};

struct socket_buffer {
	int size;
	int offset;
	struct buffer_node *head;
	struct buffer_node *tail;
};

// 释放 freepool 空闲池的消息内存地址
static int
lfreepool(lua_State *L) {
	struct buffer_node * pool = lua_touserdata(L, 1);
	// lua_rawlen 返回给定索引处值的固有“长度”,对于用户数据，它指为该用户数据分配的内存块的大小
	// 在这里是通过 lua_newuserdata 申请的空间，所以为用户数据，表示分配的内存块大小,除以每个节点的大小后得到节点的个数
	int sz = lua_rawlen(L,1) / sizeof(*pool);	
	int i;
	for (i=0;i<sz;i++) {
		struct buffer_node *node = &pool[i];
		if (node->msg) {
			skynet_free(node->msg);
			node->msg = NULL;
		}
	}
	return 0;
}

 /*
 
 分配 sz 大小空闲池数组

  |<---------------------------------------------------- sz ---------------------------------------------------->|
 ┏━━━━━━┯━━━━━━┯━━━━━━┯━━━━━━┯━━━━━━┯━━━━━━┯━━━━━━┯━━━━━━┓
 ┃buffer_node │            │	           │            │	           │    	     │	           │     ...    ┃
 ┗━━━━━━┷━━━━━━┷━━━━━━┷━━━━━━┷━━━━━━┷━━━━━━┷━━━━━━┷━━━━━━┛

 */

static int
lnewpool(lua_State *L, int sz)
{
	// 分配一块指定大小的内存块， 把内存块地址作为一个完全用户数据压栈， 并返回这个地址。 此时 pool 地址在栈顶
	struct buffer_node * pool = lua_newuserdata(L, sizeof(struct buffer_node) * sz);
	int i;
	for (i=0;i<sz;i++)
	{
		pool[i].msg = NULL;
		pool[i].sz = 0;
		pool[i].next = &pool[i+1];
	}
	pool[sz-1].next = NULL;
	// int luaL_newmetatable (lua_State *L, const char *tname);
	// 如果注册表中已存在键 tname，返回 0 。
	// 为用户数据的元表创建一张新表。 向这张表加入 __name = tname 键值对， 并将 [tname] = new table 添加到注册表中， 返回 1 。
	// 给 pool 设置一个原表，原表就是注册表key为 "buffer_pool" 指向的表，这个表的内容是 ["__gc"]=lfreepool
	if (luaL_newmetatable(L, "buffer_pool"))
	{
		// 将一个 C 函数压栈。 这个函数接收一个 C 函数指针， 并将一个类型为 function 的 Lua 值压栈。
		// 当这个栈顶的值被调用时，将触发对应的 C 函数。注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值
		lua_pushcfunction(L, lfreepool); // #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
		lua_setfield(L, -2, "__gc");
	}
	lua_setmetatable(L, -2); // 把一张表弹出栈，并将其设为给定索引处的值的元表。 也就是把上面注册的表设置为 pool 的元表
	// 这个函数把当前栈顶的表设置为 -2 就是 pool 的元表, 然后把 "buffer_pool" 踢出， pool 地址这个时候就是在栈顶
	return 1;
}

static int
lnewbuffer(lua_State *L) {
	struct socket_buffer * sb = lua_newuserdata(L, sizeof(*sb));	
	sb->size = 0;
	sb->offset = 0;
	sb->head = NULL;
	sb->tail = NULL;
	
	return 1;
}

/*
	userdata send_buffer
	table pool
	lightuserdata msg
	int size

	return size

	Comment: The table pool record all the buffers chunk, 
	and the first index [1] is a lightuserdata : free_node. We can always use this pointer for struct buffer_node .
	The following ([2] ...)  userdatas in table pool is the buffer chunk (for struct buffer_node), 
	we never free them until the VM closed. The size of first chunk ([2]) is 16 struct buffer_node,
	and the second size is 32 ... The largest size of chunk is LARGE_PAGE_NODE (4096)

	lpushbbuffer will get a free struct buffer_node from table pool, and then put the msg/size in it.
	lpopbuffer return the struct buffer_node back to table pool (By calling return_free_node).
 */

// 在 socket.lua 文件中这个函数是这样子调用
// local sz = driver.push(s.buffer, buffer_pool, data, size)
// 其中 local buffer_pool = {}	-- store all message buffer object
// 在定义这个 buffer_pool 的时候就是为 LUA_TTABLE 类型

static int
lpushbuffer(lua_State *L)
{
	struct socket_buffer *sb = lua_touserdata(L,1);
	if (sb == NULL) {
		return luaL_error(L, "need buffer object at param 1");
	}
	char * msg = lua_touserdata(L,3);
	if (msg == NULL) {
		return luaL_error(L, "need message block at param 3");
	}
	int pool_index = 2;
	luaL_checktype(L,pool_index,LUA_TTABLE);
	int sz = luaL_checkinteger(L,4);
	lua_rawgeti(L,pool_index,1); // 把 buffer_pool[1] 的值压栈， 这里的 buffer_pool 是指给定索引 pool_index 处的表。
	struct buffer_node * free_node = lua_touserdata(L,-1);	// sb poolt msg size free_node
	lua_pop(L,1); // 从栈中弹出 1 个元素
	if (free_node == NULL)
	{
		int tsz = lua_rawlen(L,pool_index); // 返回lua中定义的那个 buffer_pool 表的长度
		if (tsz == 0)
		{
			tsz++;
		}
		int size = 8;
		if (tsz <= LARGE_PAGE_NODE-3)
		{
			// 当第一次的时候，buffer_pool 表的长度为 0，所以 tsz++ 之后 tsz 等于 1，所以第一个 size = 8 << 1 = 8 * 2^1 = 16,
			// 正如上面注释所说的 The size of first chunk ([2]) is 16 struct buffer_node,
			// size 的最大值 size = 8 << LARGE_PAGE_NODE-3 = 8 << 9 = 8 * 2^9 = 8 * 512 = 4096
			// 正如上面注释所说的 The largest size of chunk is LARGE_PAGE_NODE (4096) 也就是 2^LARGE_PAGE_NODE = 2^12 = 4096
			size <<= tsz;  
		}
		else
		{
			size <<= LARGE_PAGE_NODE-3;
		}
		lnewpool(L, size); // 生成一个大小为 szie 新的空闲连续数组
		free_node = lua_touserdata(L,-1);
		// 等价于 buffer_pool[tsz+1] = v ， 这里的 buffer_pool 是指给定索引处的表， 而 v 是栈顶的值。
		// 此时栈顶的值也就是lnewpool里面生成的空闲数组里面的首地址
		lua_rawseti(L, pool_index, tsz+1);
	}
	lua_pushlightuserdata(L, free_node->next);
	
	// 把空闲的第一个节点放到
	lua_rawseti(L, pool_index, 1);	// sb poolt msg size // buffer_pool[1] = free_node->next;
	free_node->msg = msg;
	free_node->sz = sz;
	free_node->next = NULL;

	if (sb->head == NULL)
	{
		// struct socket_buffer *sb 为空，存第一个数据
		assert(sb->tail == NULL);
		sb->head = sb->tail = free_node;
	}
	else
	{
		// 把新加入的节点放到尾指针
		sb->tail->next = free_node;
		sb->tail = free_node;
	}
	sb->size += sz;

	lua_pushinteger(L, sb->size);

	return 1;
}

static void
return_free_node(lua_State *L, int pool, struct socket_buffer *sb)
{
	struct buffer_node *free_node = sb->head;
	sb->offset = 0;
	sb->head = free_node->next;
	if (sb->head == NULL)
	{
		sb->tail = NULL;
	}
	lua_rawgeti(L,pool,1); // 取 pool 索引处的表也就是 buffer_pool 表，把buffer_pool[1] 的值压栈，此时栈顶为 buffer_pool[1] 的值
	free_node->next = lua_touserdata(L,-1); // 也就是 free_node->next = buffer_pool[1]，把这个空闲节点放到socket_buffer的链表头部
	lua_pop(L,1); // 把 buffer_pool[1] 弹出栈
	skynet_free(free_node->msg);
	free_node->msg = NULL;
	free_node->sz = 0;
	lua_pushlightuserdata(L, free_node);
	lua_rawseti(L, pool, 1);
}

// pop_lstring(L,sb,sz,0);

static void
pop_lstring(lua_State *L, struct socket_buffer *sb, int sz, int skip)
{
	struct buffer_node * current = sb->head;
	if (sz < current->sz - sb->offset)
	{
		lua_pushlstring(L, current->msg + sb->offset, sz-skip);
		sb->offset+=sz;
		return;
	}
	if (sz == current->sz - sb->offset)
	{
		lua_pushlstring(L, current->msg + sb->offset, sz-skip);
		return_free_node(L,2,sb);
		return;
	}

	luaL_Buffer b;
	luaL_buffinit(L, &b);
	for (;;)
	{
		int bytes = current->sz - sb->offset;
		if (bytes >= sz)
		{
			if (sz > skip)
			{
				luaL_addlstring(&b, current->msg + sb->offset, sz - skip);
			} 
			sb->offset += sz;
			if (bytes == sz)
			{
				return_free_node(L,2,sb);
			}
			break;
		}
		int real_sz = sz - skip;
		if (real_sz > 0)
		{
			luaL_addlstring(&b, current->msg + sb->offset, (real_sz < bytes) ? real_sz : bytes);
		}
		return_free_node(L,2,sb);
		sz-=bytes;
		if (sz == 0)
		{
			break;
		}
		current = sb->head;
		assert(current);
	}
	luaL_pushresult(&b);
}

static int
lheader(lua_State *L)
{
	size_t len;
	const uint8_t * s = (const uint8_t *)luaL_checklstring(L, 1, &len);
	if (len > 4 || len < 1)
	{
		return luaL_error(L, "Invalid read %s", s);
	}
	int i;
	size_t sz = 0;
	for (i=0;i<(int)len;i++)
	{
		sz <<= 8;
		sz |= s[i];
	}

	lua_pushinteger(L, (lua_Integer)sz);

	return 1;
}

/*
	userdata send_buffer
	table pool
	integer sz 
 */
// 这个函数在 lua-socket.c 里面是这样子调用	local ret = driver.pop(s.buffer, buffer_pool, sz)
// 

static int
lpopbuffer(lua_State *L)
{
	struct socket_buffer * sb = lua_touserdata(L, 1);
	if (sb == NULL)
	{
		return luaL_error(L, "Need buffer object at param 1");
	}
	luaL_checktype(L,2,LUA_TTABLE);
	int sz = luaL_checkinteger(L,3);
	if (sb->size < sz || sz == 0)
	{
		lua_pushnil(L);
	}
	else
	{
		pop_lstring(L,sb,sz,0);
		sb->size -= sz;
	}
	lua_pushinteger(L, sb->size);
	return 2;
}

/*
	userdata send_buffer
	table pool
 */
static int
lclearbuffer(lua_State *L)
{
	struct socket_buffer * sb = lua_touserdata(L, 1);
	if (sb == NULL)
	{
		if (lua_isnil(L, 1))
		{
			return 0;
		}
		return luaL_error(L, "Need buffer object at param 1");
	}
	luaL_checktype(L,2,LUA_TTABLE);
	while(sb->head)
	{
		return_free_node(L,2,sb);
	}
	sb->size = 0;
	return 0;
}

static int
lreadall(lua_State *L) {
	struct socket_buffer * sb = lua_touserdata(L, 1);
	if (sb == NULL) {
		return luaL_error(L, "Need buffer object at param 1");
	}
	luaL_checktype(L,2,LUA_TTABLE);
	luaL_Buffer b;
	luaL_buffinit(L, &b);
	while(sb->head) {
		struct buffer_node *current = sb->head;
		luaL_addlstring(&b, current->msg + sb->offset, current->sz - sb->offset);
		return_free_node(L,2,sb);
	}
	luaL_pushresult(&b);
	sb->size = 0;
	return 1;
}

static int
ldrop(lua_State *L) {
	void * msg = lua_touserdata(L,1);
	luaL_checkinteger(L,2);
	skynet_free(msg);
	return 0;
}

static bool
check_sep(struct buffer_node * node, int from, const char *sep, int seplen) {
	for (;;) {
		int sz = node->sz - from;
		if (sz >= seplen) {
			return memcmp(node->msg+from,sep,seplen) == 0;
		}
		if (sz > 0) {
			if (memcmp(node->msg + from, sep, sz)) {
				return false;
			}
		}
		node = node->next;
		sep += sz;
		seplen -= sz;
		from = 0;
	}
}

/*
	userdata send_buffer
	table pool , nil for check
	string sep
 */
static int
lreadline(lua_State *L) {
	struct socket_buffer * sb = lua_touserdata(L, 1);
	if (sb == NULL) {
		return luaL_error(L, "Need buffer object at param 1");
	}
	// only check
	bool check = !lua_istable(L, 2);
	size_t seplen = 0;
	const char *sep = luaL_checklstring(L,3,&seplen);
	int i;
	struct buffer_node *current = sb->head;
	if (current == NULL)
		return 0;
	int from = sb->offset;
	int bytes = current->sz - from;
	for (i=0;i<=sb->size - (int)seplen;i++) {
		if (check_sep(current, from, sep, seplen)) {
			if (check) {
				lua_pushboolean(L,true);
			} else {
				pop_lstring(L, sb, i+seplen, seplen);
				sb->size -= i+seplen;
			}
			return 1;
		}
		++from;
		--bytes;
		if (bytes == 0) {
			current = current->next;
			from = 0;
			if (current == NULL)
				break;
			bytes = current->sz;
		}
	}
	return 0;
}

static int
lstr2p(lua_State *L) {
	size_t sz = 0;
	const char * str = luaL_checklstring(L,1,&sz);
	void *ptr = skynet_malloc(sz);
	memcpy(ptr, str, sz);
	lua_pushlightuserdata(L, ptr);
	lua_pushinteger(L, (int)sz);
	return 2;
}

// for skynet socket

/*
	lightuserdata msg
	integer size

	return type n1 n2 ptr_or_string
*/
static int
lunpack(lua_State *L) {
	struct skynet_socket_message *message = lua_touserdata(L,1);
	int size = luaL_checkinteger(L,2);

	lua_pushinteger(L, message->type);
	lua_pushinteger(L, message->id);
	lua_pushinteger(L, message->ud);
	if (message->buffer == NULL) {
		lua_pushlstring(L, (char *)(message+1),size - sizeof(*message));
	} else {
		lua_pushlightuserdata(L, message->buffer);
	}
	if (message->type == SKYNET_SOCKET_TYPE_UDP) {
		int addrsz = 0;
		const char * addrstring = skynet_socket_udp_address(message, &addrsz);
		if (addrstring) {
			lua_pushlstring(L, addrstring, addrsz);
			return 5;
		}
	}
	return 4;
}

static const char *
address_port(lua_State *L, char *tmp, const char * addr, int port_index, int *port) {
	const char * host;
	if (lua_isnoneornil(L,port_index)) {
		host = strchr(addr, '[');
		if (host) {
			// is ipv6
			++host;
			const char * sep = strchr(addr,']');
			if (sep == NULL) {
				luaL_error(L, "Invalid address %s.",addr);
			}
			memcpy(tmp, host, sep-host);
			tmp[sep-host] = '\0';
			host = tmp;
			sep = strchr(sep + 1, ':');
			if (sep == NULL) {
				luaL_error(L, "Invalid address %s.",addr);
			}
			*port = strtoul(sep+1,NULL,10);
		} else {
			// is ipv4
			const char * sep = strchr(addr,':');
			if (sep == NULL) {
				luaL_error(L, "Invalid address %s.",addr);
			}
			memcpy(tmp, addr, sep-addr);
			tmp[sep-addr] = '\0';
			host = tmp;
			*port = strtoul(sep+1,NULL,10);
		}
	} else {
		host = addr;
		*port = luaL_optinteger(L,port_index, 0);
	}
	return host;
}

static int
lconnect(lua_State *L) {
	size_t sz = 0;
	const char * addr = luaL_checklstring(L,1,&sz);
	char tmp[sz];
	int port = 0;
	const char * host = address_port(L, tmp, addr, 2, &port);
	if (port == 0) {
		return luaL_error(L, "Invalid port");
	}
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int id = skynet_socket_connect(ctx, host, port);
	lua_pushinteger(L, id);

	return 1;
}

static int
lclose(lua_State *L) {
	int id = luaL_checkinteger(L,1);
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	skynet_socket_close(ctx, id);
	return 0;
}

static int
lshutdown(lua_State *L) {
	int id = luaL_checkinteger(L,1);
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	skynet_socket_shutdown(ctx, id);
	return 0;
}

static int
llisten(lua_State *L) {
	const char * host = luaL_checkstring(L,1);
	int port = luaL_checkinteger(L,2);
	int backlog = luaL_optinteger(L,3,BACKLOG);
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int id = skynet_socket_listen(ctx, host,port,backlog);
	if (id < 0) {
		return luaL_error(L, "Listen error");
	}

	lua_pushinteger(L,id);
	return 1;
}

static size_t
count_size(lua_State *L, int index) {
	size_t tlen = 0;
	int i;
	for (i=1;lua_geti(L, index, i) != LUA_TNIL; ++i) {
		size_t len;
		luaL_checklstring(L, -1, &len);
		tlen += len;
		lua_pop(L,1);
	}
	lua_pop(L,1);
	return tlen;
}

static void
concat_table(lua_State *L, int index, void *buffer, size_t tlen) {
	char *ptr = buffer;
	int i;
	for (i=1;lua_geti(L, index, i) != LUA_TNIL; ++i) {
		size_t len;
		const char * str = lua_tolstring(L, -1, &len);
		if (str == NULL || tlen < len) {
			break;
		}
		memcpy(ptr, str, len);
		ptr += len;
		tlen -= len;
		lua_pop(L,1);
	}
	if (tlen != 0) {
		skynet_free(buffer);
		luaL_error(L, "Invalid strings table");
	}
	lua_pop(L,1);
}

static void *
get_buffer(lua_State *L, int index, int *sz) {
	void *buffer;
	switch(lua_type(L, index)) {
		const char * str;
		size_t len;
	case LUA_TUSERDATA:
	case LUA_TLIGHTUSERDATA:
		buffer = lua_touserdata(L,index);
		*sz = luaL_checkinteger(L,index+1);
		break;
	case LUA_TTABLE:
		// concat the table as a string
		len = count_size(L, index);
		buffer = skynet_malloc(len);
		concat_table(L, index, buffer, len);
		*sz = (int)len;
		break;
	default:
		str =  luaL_checklstring(L, index, &len);
		buffer = skynet_malloc(len);
		memcpy(buffer, str, len);
		*sz = (int)len;
		break;
	}
	return buffer;
}

static int
lsend(lua_State *L) {
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int id = luaL_checkinteger(L, 1);
	int sz = 0;
	void *buffer = get_buffer(L, 2, &sz);
	int err = skynet_socket_send(ctx, id, buffer, sz);
	lua_pushboolean(L, !err);
	return 1;
}

static int
lsendlow(lua_State *L) {
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int id = luaL_checkinteger(L, 1);
	int sz = 0;
	void *buffer = get_buffer(L, 2, &sz);
	int err = skynet_socket_send_lowpriority(ctx, id, buffer, sz);
	lua_pushboolean(L, !err);
	return 1;
}

static int
lbind(lua_State *L) {
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int fd = luaL_checkinteger(L, 1);
	int id = skynet_socket_bind(ctx,fd);
	lua_pushinteger(L,id);
	return 1;
}

static int
lstart(lua_State *L) {
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int id = luaL_checkinteger(L, 1);
	skynet_socket_start(ctx,id);
	return 0;
}

static int
lnodelay(lua_State *L) {
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int id = luaL_checkinteger(L, 1);
	skynet_socket_nodelay(ctx,id);
	return 0;
}

static int
ludp(lua_State *L) {
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	size_t sz = 0;
	const char * addr = lua_tolstring(L,1,&sz);
	char tmp[sz];
	int port = 0;
	const char * host = NULL;
	if (addr) {
		host = address_port(L, tmp, addr, 2, &port);
	}

	int id = skynet_socket_udp(ctx, host, port);
	if (id < 0) {
		return luaL_error(L, "udp init failed");
	}
	lua_pushinteger(L, id);
	return 1;
}

static int
ludp_connect(lua_State *L) {
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int id = luaL_checkinteger(L, 1);
	size_t sz = 0;
	const char * addr = luaL_checklstring(L,2,&sz);
	char tmp[sz];
	int port = 0;
	const char * host = NULL;
	if (addr) {
		host = address_port(L, tmp, addr, 3, &port);
	}

	if (skynet_socket_udp_connect(ctx, id, host, port)) {
		return luaL_error(L, "udp connect failed");
	}

	return 0;
}

static int
ludp_send(lua_State *L) {
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));
	int id = luaL_checkinteger(L, 1);
	const char * address = luaL_checkstring(L, 2);
	int sz = 0;
	void *buffer = get_buffer(L, 3, &sz);
	int err = skynet_socket_udp_send(ctx, id, address, buffer, sz);

	lua_pushboolean(L, !err);

	return 1;
}

static int
ludp_address(lua_State *L) {
	size_t sz = 0;
	const uint8_t * addr = (const uint8_t *)luaL_checklstring(L, 1, &sz);
	uint16_t port = 0;
	memcpy(&port, addr+1, sizeof(uint16_t));
	port = ntohs(port);
	const void * src = addr+3;
	char tmp[256];
	int family;
	if (sz == 1+2+4) {
		family = AF_INET;
	} else {
		if (sz != 1+2+16) {
			return luaL_error(L, "Invalid udp address");
		}
		family = AF_INET6;
	}
	if (inet_ntop(family, src, tmp, sizeof(tmp)) == NULL) {
		return luaL_error(L, "Invalid udp address");
	}
	lua_pushstring(L, tmp);
	lua_pushinteger(L, port);
	return 2;
}

static void
getinfo(lua_State *L, struct socket_info *si) {
	lua_newtable(L);
	lua_pushinteger(L, si->id);
	lua_setfield(L, -2, "id");
	lua_pushinteger(L, si->opaque);
	lua_setfield(L, -2, "address");
	switch(si->type) {
	case SOCKET_INFO_LISTEN:
		lua_pushstring(L, "LISTEN");
		lua_setfield(L, -2, "type");
		lua_pushinteger(L, si->read);
		lua_setfield(L, -2, "accept");
		lua_pushinteger(L, si->rtime);
		lua_setfield(L, -2, "rtime");
		if (si->name[0]) {
			lua_pushstring(L, si->name);
			lua_setfield(L, -2, "sock");
		}
		return;
	case SOCKET_INFO_TCP:
		lua_pushstring(L, "TCP");
		break;
	case SOCKET_INFO_UDP:
		lua_pushstring(L, "UDP");
		break;
	case SOCKET_INFO_BIND:
		lua_pushstring(L, "BIND");
		break;
	default:
		lua_pushstring(L, "UNKNOWN");
		lua_setfield(L, -2, "type");
		return;
	}
	lua_setfield(L, -2, "type");
	lua_pushinteger(L, si->read);
	lua_setfield(L, -2, "read");
	lua_pushinteger(L, si->write);
	lua_setfield(L, -2, "write");
	lua_pushinteger(L, si->wbuffer);
	lua_setfield(L, -2, "wbuffer");
	lua_pushinteger(L, si->rtime);
	lua_setfield(L, -2, "rtime");
	lua_pushinteger(L, si->wtime);
	lua_setfield(L, -2, "wtime");
	if (si->name[0]) {
		lua_pushstring(L, si->name);
		lua_setfield(L, -2, "peer");
	}
}

static int
linfo(lua_State *L) {
	lua_newtable(L);
	struct socket_info * si = skynet_socket_info();
	struct socket_info * temp = si;
	int n = 0;
	while (temp) {
		getinfo(L, temp);
		lua_seti(L, -2, ++n);
		temp = temp->next;
	}
	socket_info_release(si);
	return 1;
}

LUAMOD_API int
luaopen_skynet_socketdriver(lua_State *L) {
	luaL_checkversion(L);
	luaL_Reg l[] = {
		{ "buffer", lnewbuffer },
		{ "push", lpushbuffer },
		{ "pop", lpopbuffer },
		{ "drop", ldrop },
		{ "readall", lreadall },
		{ "clear", lclearbuffer },
		{ "readline", lreadline },
		{ "str2p", lstr2p },
		{ "header", lheader },
		{ "info", linfo },

		{ "unpack", lunpack },
		{ NULL, NULL },
	};
	luaL_newlib(L,l);
	luaL_Reg l2[] = {
		{ "connect", lconnect },
		{ "close", lclose },
		{ "shutdown", lshutdown },
		{ "listen", llisten },
		{ "send", lsend },
		{ "lsend", lsendlow },
		{ "bind", lbind },
		{ "start", lstart },
		{ "nodelay", lnodelay },
		{ "udp", ludp },
		{ "udp_connect", ludp_connect },
		{ "udp_send", ludp_send },
		{ "udp_address", ludp_address },
		{ NULL, NULL },
	};
	lua_getfield(L, LUA_REGISTRYINDEX, "skynet_context");
	struct skynet_context *ctx = lua_touserdata(L,-1);
	if (ctx == NULL) {
		return luaL_error(L, "Init skynet context first");
	}

	luaL_setfuncs(L,l2,1);

	/*
	void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);
把数组 l 中的所有函数 （参见 luaL_Reg） 注册到栈顶的表中（该表在可选的上值之下，见下面的解说）。

若 nup 不为零， 所有的函数都共享 nup 个上值。 这些值必须在调用之前，压在表之上。 这些值在注册完毕后都会从栈弹出。
弹出后这里的ctx存在函数里面
	*/
	return 1;
}
