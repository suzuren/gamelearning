

-----------------------------------------------------------------------------------------------------------------------

void luaL_checktype (lua_State *L, int arg, int t);
检查函数的第 arg 个参数的类型是否是 t。 参见 lua_type 查阅类型 t 的编码。如果不是类型 t 就 throw

-----------------------------------------------------------------------------------------------------------------------

int lua_type (lua_State *L, int index);
返回给定有效索引处值的类型， 当索引无效（或无法访问）时则返回 LUA_TNONE。
lua_type 返回的类型被编码为一些个在 lua.h 中定义的常量： LUA_TNIL， LUA_TNUMBER， LUA_TBOOLEAN， LUA_TSTRING， 
LUA_TTABLE， LUA_TFUNCTION， LUA_TUSERDATA， LUA_TTHREAD， LUA_TLIGHTUSERDATA。

-----------------------------------------------------------------------------------------------------------------------

lua_Integer luaL_checkinteger (lua_State *L, int arg);
检查函数的第 arg 个参数是否是一个 整数（或是可以被转换为一个整数） 并以 lua_Integer 类型返回这个整数值。

-----------------------------------------------------------------------------------------------------------------------

int lua_rawgeti (lua_State *L, int index, lua_Integer n);
把 t[n] 的值压栈， 这里的 t 是指给定索引处的表。 这是一次直接访问；就是说，它不会触发元方法。
返回入栈值的类型。

-----------------------------------------------------------------------------------------------------------------------

void *lua_touserdata (lua_State *L, int index);
如果给定索引处的值是一个完全用户数据， 函数返回其内存块的地址。 如果值是一个轻量用户数据， 那么就返回它表示的指针。 否则，返回 NULL 。

-----------------------------------------------------------------------------------------------------------------------

void lua_pop (lua_State *L, int n);
从栈中弹出 n 个元素。

-----------------------------------------------------------------------------------------------------------------------

size_t lua_rawlen (lua_State *L, int index);
返回给定索引处值的固有“长度”： 对于字符串，它指字符串的长度； 对于表；它指不触发元方法的情况下取长度操作（'#'）应得到的值； 对于用户数据，
它指为该用户数据分配的内存块的大小； 对于其它值，它为 0 。

-----------------------------------------------------------------------------------------------------------------------

void *lua_newuserdata (lua_State *L, size_t size);
这个函数分配一块指定大小的内存块， 把内存块地址作为一个完全用户数据压栈， 并返回这个地址。 宿主程序可以随意使用这块内存。

-----------------------------------------------------------------------------------------------------------------------

void lua_pushlightuserdata (lua_State *L, void *p);
把一个轻量用户数据压栈。
用户数据是保留在 Lua 中的 C 值。 轻量用户数据 表示一个指针 void*。 它是一个像数字一样的值： 你不需要专门创建它，它也没有独立的元表，
而且也不会被收集（因为从来不需要创建）。 只要表示的 C 地址相同，两个轻量用户数据就相等。

-----------------------------------------------------------------------------------------------------------------------

void lua_rawseti (lua_State *L, int index, lua_Integer i);
等价于 t[i] = v ， 这里的 t 是指给定索引处的表， 而 v 是栈顶的值。
这个函数会将值弹出栈。 赋值是直接的；即不会触发元方法。

-----------------------------------------------------------------------------------------------------------------------

typedef struct luaL_Buffer luaL_Buffer;
字符串缓存 的类型。
字符串缓存可以让 C 代码分段构造一个 Lua 字符串。 使用模式如下：

首先定义一个类型为 luaL_Buffer 的变量 b。
调用 luaL_buffinit(L, &b) 初始化它。
然后调用 luaL_add* 这组函数向其添加字符串片断。
最后调用 luaL_pushresult(&b) 。 最后这次调用会在栈顶留下最终的字符串。
如果你预先知道结果串的长度， 你可以这样使用缓存：

首先定义一个类型为 luaL_Buffer 的变量 b。
然后调用 luaL_buffinitsize(L, &b, sz) 预分配 sz 大小的空间。
接着将字符串复制入这个空间。
最后调用 luaL_pushresultsize(&b, sz)， 这里的 sz 指已经复制到缓存内的字符串长度。
一般的操作过程中，字符串缓存会使用不定量的栈槽。 因此，在使用缓存中，你不能假定目前栈顶在哪。 在对缓存操作的函数调用间，
你都可以使用栈，只需要保证栈平衡即可； 即，在你做一次缓存操作调用时，当时的栈位置和上次调用缓存操作后的位置相同。 
（对于 luaL_addvalue 是个唯一的例外。） 在调用完 luaL_pushresult 后， 栈会恢复到缓存初始化时的位置上，并在顶部压入最终的字符串。

-----------------------------------------------------------------------------------------------------------------------



-----------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------










