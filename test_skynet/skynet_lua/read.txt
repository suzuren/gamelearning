
--------------------------------------------------------------------------

string.char (・・・)
接收零或更多的整数。 返回和参数数量相同长度的字符串。 其中每个字符的内部编码值等于对应的参数值。
数字编码没有必要跨平台

--------------------------------------------------------------------------

string.byte (s [, i [, j]])
返回字符 s[i]， s[i+1]， ...　，s[j] 的内部数字编码。 i 的默认值是 1 ； j 的默认值是 i。 这些索引以函数 string.sub 的规则修正。

--------------------------------------------------------------------------

lua_pushliteral
[-0, +1, e]
const char *lua_pushliteral (lua_State *L, const char *s);
这个宏等价于 lua_pushstring， 区别仅在于只能在 s 是一个字面量时才能用它。 它会自动给出字符串的长度。

--------------------------------------------------------------------------

lua_pushstring
[-0, +1, e]
const char *lua_pushstring (lua_State *L, const char *s);
将指针 s 指向的零结尾的字符串压栈。Lua 对这个字符串做一个内部副本（或是复用一个副本）， 因此 s 处的内存在函数返回后，可以释放掉或是立刻重用于其它用途。

返回内部副本的指针。

如果 s 为 NULL，将 nil 压栈并返回 NULL。

--------------------------------------------------------------------------

lua_pushcclosure
[-n, +1, e]
void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
把一个新的 C 闭包压栈。

当创建了一个 C 函数后， 你可以给它关联一些值， 这就是在创建一个 C 闭包（参见 §4.4）； 接下来无论函数何时被调用，
这些值都可以被这个函数访问到。 
为了将一些值关联到一个 C 函数上， 首先这些值需要先被压入堆栈（如果有多个值，第一个先压）。 
接下来调用 lua_pushcclosure 来创建出闭包并把这个 C 函数压到栈上。 
参数 n 告之函数有多少个值需要关联到函数上。 lua_pushcclosure 也会把这些值从栈上弹出。

n 的最大值是 255 。

当 n 为零时， 这个函数将创建出一个 轻量 C 函数， 它就是一个指向 C 函数的指针。 这种情况下，不可能抛出内存错误。

--------------------------------------------------------------------------

 C 闭包
当 C 函数被创建出来， 我们有可能会把一些值关联在一起， 也就是创建一个 C 闭包 （参见 lua_pushcclosure）； 
这些被关联起来的值被叫做 上值 ， 它们可以在函数被调用的时候访问的到。

无论何时去调用 C 函数， 函数的上值都可以用伪索引定位。 我们可以用 lua_upvalueindex 这个宏来生成这些伪索引。 
第一个关联到函数的值放在 lua_upvalueindex(1) 位置处，依此类推。 使用 lua_upvalueindex(n) 时， 
若 n 大于当前函数的总上值个数 （但不可以大于 256）会产生一个可接受的但无效的索引。

--------------------------------------------------------------------------




--------------------------------------------------------------------------




--------------------------------------------------------------------------
