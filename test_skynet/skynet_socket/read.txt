


-----------------------------------------------------------------------------------

skynet_mq

https://blog.codingnow.com/2012/10/bug_and_lockfree_queue.html

全局消息队列处理的业务很简单，就是存放着系统所有服务的二级消息队列。每个工作线程
都是平等的，从中取得一个二级消息队列，处理完其中的一个消息，然后将其压回去。

原来的锁最重要的用途是在全局消息队列容量不够时，保护重新分配内存的过程不被干扰。
但实际上，全局消息队列的预容量大于系统中服务体的数量的话，是永远够用的。我设置了
单台机器支撑的服务体数量上限为 64K 个，那么消息队列预分配 64K 个单元，就无需动态
调整。


https://blog.codingnow.com/2014/05/skynet_mq_flags.html

https://blog.codingnow.com/2012/08/skynet_bug.html

当 ctx 销毁前，由它向其 mq 设入一个清理标记。然后在 globalmq 取出 mq ，发现已经找
不到 handle 对应的 ctx 时，先判断是否有清理标记。如果没有，再将 mq 重放进 globalmq
，直到清理标记有效，在销毁 mq 。


https://blog.codingnow.com/2016/01/skynet2.html


https://blog.codingnow.com/2016/01/skynet_mq.html



-----------------------------------------------------------------------------------


-----------------------------------------------------------------------------------
