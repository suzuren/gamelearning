
//struct timespec
//{
//time_t tv_sec; // seconds[秒]
//long tv_nsec; // nanoseconds[纳秒]
//};
//int clock_gettime(clockid_t clk_id, struct timespect *tp);
////@clk_id:
//CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变
//CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响
//CLOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间
//CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间



首先 skynet 的定时器 node->time 类型为 uint32_t , 范围是 0 ~ 2^32 - 1 ,  skynet 实现的 时间轮的思路是这样的（我想linux也是这样）：

将 32 位 分为五个部分，
struct link_list near[TIME_NEAR];　(000000 000000 000000 000000 11111111)  低8位 表示 0 ~ 2^8 - 1 即 0 ~ 255 个 tick ，
这里每个 near[x] 的精度是一个 tick  ，即 10 毫秒

下面是四个数组，每个数组有 TIME_LEVEL  个 slot ，即 2^6 = 64 个 slot， 

link_list[0] 数组， 每个 slot 表示的精度是 2^8 ， 即在这个数组中 每一个 slot 比上一个 slot 多 256 个 tick ，
link_list[0] 表示的范围是 (2^8 ~ 2^14 - 1), 即 node->expire 时间在这个范围内的，都被分到这个数组里

link_list[1]数组， 每个 slot 表示的精度是 2^8 * 2^6 ,
link_list[1] 表示的范围是 (2^14 ~ 2^20 - 1), 即 node->expire 时间在这个范围内的 (2^14 ~ 2^20 - 1)，都被分到这个数组里

link_list[2]数组， 每个 slot 表示的精度是 2^8 * 2^6 * 2^6 ,
link_list[2] 表示的范围是 (2^20 ~ 2^26 - 1), 即 node->expire 时间在这个范围内的 (2^20 ~ 2^26 - 1)，都被分到这个数组里

link_list[3]数组， 每个 slot 表示的精度是 2^8 * 2^6 * 2^6 * 2^6 , 
link_list[3] 表示的范围是 (2^26 ~ 2^32 - 1), 即 node->expire 时间在 这个范围内的  (2^26 ~ 2^32 - 1),，都被分到这个数组里








 while ((ct & (mask-1))==0)
(ct & (mask-1)) -> ct & 0000 1111 1111
ct就是低八位都要是0的时候 这个条件才成立
也就是 需要 ++T->time 这个累加 256次
当256次的时候
    ct = 0001 0000 0000
mask-1 = 0000 1111 1111
这个时候相与操作 才有可能等于0
所以需要执行256次tic才会去移动t数组的定时器
在256次之前的定时器都是放在near里面
所以在执行256次tick之前也不需要关心t数组远时间的定时器
这个时候肯定是不会执行到的

 1 // skynet-src/skynet_timer.c
 2 static void
 3 move_list(struct timer *T, int level, int idx) {
 4     struct timer_node *current = link_clear(&T->t[level][idx]);
 5     while (current) {
 6         struct timer_node *temp=current->next;
 7         add_node(T,current);
 8         current=temp;
 9     }
10 }
11 
12 static void
13 timer_shift(struct timer *T) {
14     int mask = TIME_NEAR; // 2^8 = 256 -> 0001 0000 0000
15     uint32_t ct = ++T->time;
16     if (ct == 0) {
17         move_list(T, 3, 0);
18     } else {
19         uint32_t time = ct >> TIME_NEAR_SHIFT; //  8
20         int i=0;
21 
22         while ((ct & (mask-1))==0) {           // 当 ct 低八位不全为0,(ct & (mask-1)) -> ct & 0000 1111 1111  !=   0 这个时候就不需要分配
23             int idx=time & TIME_LEVEL_MASK;    // 63 -> 0011 1111
24             if (idx!=0) {
25                 move_list(T, i, idx);
26                 break;                          
27             }
28             mask <<= TIME_LEVEL_SHIFT;         //  6 左移6位
29             time >>= TIME_LEVEL_SHIFT;
30             ++i;
31         }
32     }
33 }

i = 0  mask  ->  ?0000  0000   0000 0000   0000 0001   0000 0000  - 1 -> 0000  0000   0000 0000   ?0000 0000   1111 1111?
i = 1  mask  ->  ?0000  0000   0000 0000   0100 0000   0000 0000  - 1 -> 0000  0000   0000 0000   ?0011 1111   1111 1111?
i = 2  mask  ->  ?0000  0000   0001 0000   0000 0000   0000 0000  - 1 -> 0000  0000   0000 1111   ?1111 1111   1111 1111?
i = 3  mask  ->  ?0000  0100   0000 0000   0000 0000   0000 0000  - 1 -> 0000  0011   1111 1111   ?1111 1111   1111 1111?
i = 4  mask  ->  ?0000  0000   0000 0000   0000 0000   0000 0000  - 1 -> ?1111  1111   1111 1111   1111 1111   1111 1111



当 T->time = 254 -> 0000 0000   0000 0000   0000 0000   ?1111 1110  -> ct & (mask-1)  == 0000 0000   0000 0000   0000 0000   ?1111 1110  != 0
当 T->time = 255 -> 0000 0000   0000 0000   0000 0000   ?1111 1111?  -> ct & (mask-1)  == 0000 0000   0000 0000   0000 0000   ?1111 1111  != 0
当 T->time = 256 -> 0000 0000   0000 0000   0000 0001   ?0000 0000?  -> ct & (mask-1)  == 0000 0000   0000 0000   0000 0000   ?0000 0000  == 0

所以当 T->time = 256 条件 while ((ct & (mask-1))==0) 第 1 次成立

i = 0 时 mask-1   == 0000 0000   0000 0000   ?0000 0000   1111 1111?
         ct = 256 == 0000 0000   0000 0000   0000 0001   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0

i = 1 时 mask-1   == 0000 0000   0000 0000   ?0011 1111   1111 1111?
         ct = 256 == 0000 0000   0000 0000   0000 0001   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0001   ?0000 0000? != 0

退出while循环



当 T->time = 511 -> 0000 0000   0000 0000   0000 0001   ?1111 1111?  -> ct & (mask-1)  == 0000 0000   0000 0000   0000 0000   ?1111 1111  != 0
当 T->time = 512 -> 0000 0000   0000 0000   0000 0010   ?0000 0000?  -> ct & (mask-1)  == 0000 0000   0000 0000   0000 0000   ?0000 0000  == 0

所以当 T->time = 512 条件 while ((ct & (mask-1))==0) 第 2 次成立

i = 0 时 mask-1   == 0000 0000   0000 0000   ?0000 0000   1111 1111?
         ct = 512 == 0000 0000   0000 0000   0000 0010   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0

i = 1 时 mask-1   == 0000 0000   0000 0000   ?0011 1111   1111 1111?
         ct = 256 == 0000 0000   0000 0000   0000 0010   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0010   ?0000 0000? != 0

退出 while 循环

所以执行 i=0 的间隔是 256 , 也就是操作 t[0][x] 数组下标的频率 256，是每 tick 256 次，执行一次 t[0][x]

--------------------------------------------------------------------------------------------------------------------------------------------------------------------



i = 0 时 mask-1   == 0000 0000   0000 0000   ?0000 0000   1111 1111?
       ct = ?16384? == 0000 0000   0000 0000   0100 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0

i = 1 时 mask-1   == 0000 0000   0000 0000   ?0011 1111   1111 1111?
       ct = ?16384? == 0000 0000   0000 0000   0100 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0010   ?0000 0000? == 0

i = 2 时 mask-1   == 0000 0000   0000 1111   ?1111 1111   1111 1111?
       ct = ?16384? == 0000 0000   0000 0000   0100 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0100 0000   ?0000 0000? != 0

退出 while 循环

所以执行 i=1 的间隔是 16384，也就是操作 t[1][x] 数组下标的频率 256，是每 tick 256 次，执行一次 t[1][x]


--------------------------------------------------------------------------------------------------------------------------------------------------------------------



i = 0 时 mask-1   == 0000 0000   0000 0000   ?0000 0000   1111 1111?
     ct = ??1048576?? == 0000 0000   0001 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0

i = 1 时 mask-1   == 0000 0000   0000 0000   ?0011 1111   1111 1111?
     ct = ??1048576?? == 0000 0000   0001 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0010   ?0000 0000? == 0

i = 2 时 mask-1   == 0000 0000   0000 1111   ?1111 1111   1111 1111?
     ct = ??1048576?? == 0000 0000   0001 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0000   ?0000 0000? == 0

i = 3 时 mask-1   == 0000 0011   1111 1111   ?1111 1111   1111 1111?
     ct = ??1048576?? == 0000 0000   0001 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0100 0000   ?0000 0000? != 0


退出 while 循环

所以执行 i=2 的间隔是 1048576，也就是操作 t[2][x] 数组下标的频率 256，是每 tick 1048576 次，执行一次 t[2][x]


--------------------------------------------------------------------------------------------------------------------------------------------------------------------



i = 0 时 mask-1   == 0000 0000   0000 0000   ?0000 0000   1111 1111?
    ct = ???67108864??? == 0000 0100   0000 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0

i = 1 时 mask-1   == 0000 0000   0000 0000   ?0011 1111   1111 1111?
    ct = ???67108864??? == 0000 0100   0000 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0010   ?0000 0000? == 0

i = 2 时 mask-1   == 0000 0000   0000 1111   ?1111 1111   1111 1111?
    ct = ???67108864??? == 0000 0100   0000 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0000   ?0000 0000? == 0

i = 3 时 mask-1   == 0000 0011   1111 1111   ?1111 1111   1111 1111?
    ct = ???67108864??? == 0000 0100   0000 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0000   ?0000 0000? == 0

i = 4 时 mask-1   == 1111 1111   1111 1111   ?1111 1111   1111 1111?
    ct = ???67108864??? == 0000 0100   0000 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0100   0000 0000   0000 0000   ?0000 0000? != 0



退出 while 循环

所以执行 i=3 的间隔是 67108864，也就是操作 t[3][x] 数组下标的频率 256，是每 tick 1048576 次，执行一次 t[3][x]
此时i=4的时候，mask-1 = -1  == 1111 1111   1111 1111   ?1111 1111   1111 1111?，也就是当i=4的时候，条件不会再成立 while ((ct & (mask-1))==0)


--------------------------------------------------------------------------------------------------------------------------------------------------------------------


所以t[0][x] 、t[1][x] 、t[2][x] 、t[3][x] 他们三个检测是否需要移动里面的定时器的频率是 256、 512 、16384、1048576，
即等级越大的定时器越遥远，越不关注，需要重新分配的次数也就越少。



--------------------------------------------------------------------------------------------------------------------------------------------------------------------


static void
add_node(struct timer *T,struct timer_node *node) {
	uint32_t time=node->expire;
	uint32_t current_time=T->time;
	
	if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) {
		link(&T->near[time&TIME_NEAR_MASK],node);
	} else {
		int i;
		uint32_t mask=TIME_NEAR << TIME_LEVEL_SHIFT;
		for (i=0;i<3;i++) {
			if ((time|(mask-1))==(current_time|(mask-1))) {
				break;
			}
			mask <<= TIME_LEVEL_SHIFT;
		}

		link(&T->t[i][((time>>(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) & TIME_LEVEL_MASK)],node);	
	}
}

if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) 里面
#define TIME_NEAR_MASK  255 ->  0000  0000   0000 0000   0000 0000   1111 1111
uint32_t 类型需要32位表示，把超时时间的高24位等于当前时间的高24位来判断是否是近的时间
near 这个数组大小正好是256大小，0-255表示，
time&TIME_NEAR_MASK 这个time是32位只能取出低八位，所以 time&TIME_NEAR_MASK 范围是 0 - 255
所以这个 time&TIME_NEAR_MASK 这个数值做 near 数组的下标是永远都不会越界的
相当于低八位不考虑，高24位如果是一样的，都是算近的时间。


else 里面
i = 0    mask         ->  ?0000  0000   0000 0000   0100 0000   0000 0000  - 1 -> 0000  0000   0000 0000   ?0011 1111   1111 1111? -> 所以 i=0 存放超时时间 2^14-1 到 2^8 （因为 0 到 2^8-1 的时间已经给near近的时间数组了）
i = 1    mask         ->  ?0000  0000   0001 0000   0000 0000   0000 0000  - 1 -> 0000  0000   0000 1111   ?1111 1111   1111 1111? -> 所以 i=1 存放超时时间 2^20-1 到 2^14
i = 2    mask         ->  ?0000  0100   0000 0000   0000 0000   0000 0000  - 1 -> 0000  0011   1111 1111   ?1111 1111   1111 1111? -> 所以 i=2 存放超时时间 2^26-1 到 2^20
i = 3    mask         ->  ?0000  0100   0000 0000   0000 0000   0000 0000  - 1 -> 0000  0011   1111 1111   ?1111 1111   1111 1111? -> 所以 i=3 存放超时时间 2^32-1 到 2^26
因为 i 为 3 的时候，不能进入循环，所以 mask 的值和 i 为 2 的值是一样的
所以当超时时间是和当前时间的高 18 位一样的时候可以进入 i = 0 的 t[0][x] 数组里面
所以当超时时间是和当前时间的高 12 位一样的时候可以进入 i = 1 的 t[1][x] 数组里面
所以当超时时间是和当前时间的高  6 位一样的时候可以进入 i = 2 的 t[2][x] 数组里面
剩下的都是直接进入到 i = 3 的数组里面


static void
timer_shift(struct timer *T) {
	int mask = TIME_NEAR;
	uint32_t ct = ++T->time;
	if (ct == 0) {
		move_list(T, 3, 0);
	} else {
		uint32_t time = ct >> TIME_NEAR_SHIFT;
		int i=0;

		while ((ct & (mask-1))==0) {
			int idx=time & TIME_LEVEL_MASK;
			if (idx!=0) {
				move_list(T, i, idx);
				break;				
			}
			mask <<= TIME_LEVEL_SHIFT;
			time >>= TIME_LEVEL_SHIFT;
			++i;
		}
	}
}

i = 0 时 mask-1   == 0000 0000   0000 0000   ?0000 0000   1111 1111?
         ct = 256 == 0000 0000   0000 0000   0000 0001   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0

i = 1 时 mask-1   == 0000 0000   0000 0000   ?0011 1111   1111 1111?
       ct = ?16384? == 0000 0000   0000 0000   0100 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0010   ?0000 0000? == 0

i = 2 时 mask-1   == 0000 0000   0000 1111   ?1111 1111   1111 1111?
     ct = ??1048576?? == 0000 0000   0001 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0000   ?0000 0000? == 0

i = 3 时 mask-1   == 0000 0011   1111 1111   ?1111 1111   1111 1111?
    ct = ???67108864??? == 0000 0100   0000 0000   0000 0000   ?0000 0000?
--------------------------------------------------------------------------
	  ct & mask-1 == 0000 0000   0000 0000   0000 0000   ?0000 0000? == 0


当 T->time = 256 , time = ct >> TIME_NEAR_SHIFT -> 256 >> 8 -> 0000 0000   0000 0000   0000 0001   ?0000 0000? 右移 8 位 == ?0000 0000   0000 0000   0000 0000   0000 0001

int idx=time & TIME_LEVEL_MASK;
     ?0000 0000   0000 0000   0000 0000   0000 0001
	 0000 0000   0000 0000   0000 0000   0011 1111
-----------------------------------------------------------
     ?0000 0000   0000 0000   0000 0000   0000 0001 == 1


当 T->time = 512 , time = ct >> TIME_NEAR_SHIFT -> 512 >> 8 -> 0000 0000   0000 0000   0000 0010   ?0000 0000? 右移 8 位 == ?0000 0000   0000 0000   0000 0000   0000 0010

int idx=time & TIME_LEVEL_MASK;
     ?0000 0000   0000 0000   0000 0000   0000 0010
	 0000 0000   0000 0000   0000 0000   0011 1111
-----------------------------------------------------------
     ?0000 0000   0000 0000   0000 0000   0000 0010 == 2


当 T->time = 768 , time = ct >> TIME_NEAR_SHIFT -> 768 >> 8 -> 0000 0000   0000 0000   0000 0011   ?0000 0000? 右移 8 位 == ?0000 0000   0000 0000   0000 0000   0000 0011

int idx=time & TIME_LEVEL_MASK;
     ?0000 0000   0000 0000   0000 0000   0000 0011
	 0000 0000   0000 0000   0000 0000   0011 1111
-----------------------------------------------------------
     ?0000 0000   0000 0000   0000 0000   0000 0011 == 3


...


当 T->time = ?16128? , time = ct >> TIME_NEAR_SHIFT -> ?16128? >> 8 -> 0000 0000   0000 0000   0011 1111   ?0000 0000? 右移 8 位 == ?0000 0000   0000 0000   0000 0000   0011 1111

int idx=time & TIME_LEVEL_MASK;
     ?0000 0000   0000 0000   0000 0000   0011 1111
	 0000 0000   0000 0000   0000 0000   0011 1111
-----------------------------------------------------------
     ?0000 0000   0000 0000   0000 0000   0011 1111 == 63

